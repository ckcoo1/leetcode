## 300.最长递增子序列

**难度：中等**

#### 题目描述

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

**示例1:**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**提示：**

```
1 <= nums.length <= 2500
-104 <= nums[i] <= 104
```

#### 解题思路

在快速排序算法中，哨兵划分是一种将数组分成两部分的策略，其中一部分包含所有小于基准数的元素，另一部分包含所有大于基准数的元素。这个过程可以这样理解：

1. **基准数的选择**：通常选择数组的第一个元素作为基准数。
2. **哨兵划分**：遍历数组，将所有小于基准数的元素移动到基准数的左边，所有大于基准数的元素移动到基准数的右边。完成这一步后，基准数就处于其最终排序后的位置。
3. **递归排序**：递归地对基准数左边和右边的子数组执行相同的操作。

现在，让我们考虑快速选择算法中的情况，即我们想要找到数组中第k大的元素：

- **数组长度**：假设数组长度为N。
- **目标**：找到第k大的元素，即在数组排序后位于第N-k+1个位置的元素。

在快速选择的过程中，如果我们在某次哨兵划分后发现基准数的索引正好是N-k，这意味着：

- 基准数左边有N-k个元素，这些元素都小于基准数。
- 基准数右边有k-1个元素，这些元素都大于基准数。

由于我们要找的是第k大的元素，而基准数正好将数组分成了两部分，其中一部分有k-1个元素比它大，另一部分有N-k个元素比它小，那么基准数就是第k大的元素。这是因为在排序完成后，第k大的元素应该位于第N-k+1个位置，而基准数的索引正好是N-k，说明它就是排序后应该位于第N-k+1个位置的元素。

```java
public int lengthOfLIS(int[] nums) {
        if(nums.length <= 1) {
            return nums.length;
        }
        int[] dp = new int[nums.length];
        int res = 1;
        Arrays.fill(nums, 1);
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
```
